–û—Ç–ª–∏—á–Ω–æ, –ê–ª–µ–∫—Å–∞–Ω–¥—Ä. –î–∞–≤–∞–π —Ä–µ–∞–ª–∏–∑—É–µ–º —Ç—Ä–µ—Ç–∏–π –≤–∞—Ä–∏–∞–Ω—Ç –º–æ–¥—É–ª—è ‚Äî —á–µ—Ä–µ–∑ **Graph Neural Network (GNN)**, –æ–±—É—á–∞—é—â—É—é **Value-—Ñ—É–Ω–∫—Ü–∏—é** –¥–ª—è –∫–∞–∂–¥–æ–π —Ñ–∏—Ä–º—ã –Ω–∞ –≥—Ä–∞—Ñ–µ, –∏ –∑–∞—Ç–µ–º –∏–∑–≤–ª–µ—á—ë–º **—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ, —É–¥–æ–≤–ª–µ—Ç–≤–æ—Ä—è—é—â–µ–µ —É—Å–ª–æ–≤–∏—é —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è –ù—ç—à–∞**.

---

## üîπ –û–±—â–∞—è –∏–¥–µ—è

1. **GNN –æ–±—É—á–∞–µ—Ç Value-—Ñ—É–Ω–∫—Ü–∏—é** \( V_i(v) \) ‚Äî –æ–∂–∏–¥–∞–µ–º—É—é –ø—Ä–∏–±—ã–ª—å —Ñ–∏—Ä–º—ã \(i\), –µ—Å–ª–∏ –æ–Ω–∞ –≤—ã–±–µ—Ä–µ—Ç –≤–µ—Ä—à–∏–Ω—É \(v\), –ø—Ä–∏ —Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏—è—Ö –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤.
2. **–§–∏—Ä–º–∞ –≤—ã–±–∏—Ä–∞–µ—Ç —Å—Ç—Ä–∞—Ç–µ–≥–∏—é** \(x_i\) –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ \(V_i(v)\), –ª–∏–±–æ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ: \(v_i^* = \arg\max V_i(v)\).
3. **–ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è –ù—ç—à–∞**: –Ω–∏ –æ–¥–Ω–∞ —Ñ–∏—Ä–º–∞ –Ω–µ –º–æ–∂–µ—Ç —É–ª—É—á—à–∏—Ç—å –ø—Ä–∏–±—ã–ª—å, –ø–µ—Ä–µ–π–¥—è –≤ –¥—Ä—É–≥—É—é –≤–µ—Ä—à–∏–Ω—É.

---

## üîπ –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ GNN-–º–æ–¥—É–ª—è

### –í—Ö–æ–¥:
- –ì—Ä–∞—Ñ \(G=(V,E)\), –≤–µ—Å–∞ —Ä—ë–±–µ—Ä.
- –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ \(x_{-i}\) (—Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç–µ–π).
- –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Ç—Ä–µ–±–∏—Ç–µ–ª–µ–π \(d(u)\).
- –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ñ–∏—á–∏ –≤–µ—Ä—à–∏–Ω: —Å—Ç–µ–ø–µ–Ω–∏ –≤–µ—Ä—à–∏–Ω \(d(v)\), –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä —Ñ–∏—Ä–º—ã \(i\) (one-hot –≤–µ–∫—Ç–æ—Ä).

### –§–∏—á–∏ –≤–µ—Ä—à–∏–Ω:
–î–ª—è —Ñ–∏—Ä–º—ã \(i\):
\[
\mathbf{f}_v = [\mathbf{1}, d(v), \mathbf{e}_i]
\]
–≥–¥–µ \(\mathbf{1}\) ‚Äî –∫–æ–Ω—Å—Ç–∞–Ω—Ç–∞, \(d(v)\) ‚Äî —Å—Ç–µ–ø–µ–Ω—å –≤–µ—Ä—à–∏–Ω—ã, \(\mathbf{e}_i\) ‚Äî one-hot –≤–µ–∫—Ç–æ—Ä —Ñ–∏—Ä–º—ã.

### –¶–µ–ª—å:
- –û–±—É—á–∏—Ç—å GNN, –∫–æ—Ç–æ—Ä–∞—è –∞–ø–ø—Ä–æ–∫—Å–∏–º–∏—Ä—É–µ—Ç:
  \[
  V_i(v) = \text{–æ–∂–∏–¥–∞–µ–º–∞—è –ø—Ä–∏–±—ã–ª—å —Ñ–∏—Ä–º—ã } i \text{ –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –≤ –≤–µ—Ä—à–∏–Ω–µ } v \text{ —Å —É—á—ë—Ç–æ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤}
  \]

---

## üîß –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –Ω–∞ PyTorch Geometric (—Å—Ö–µ–º–∞—Ç–∏—á–Ω–æ)

### 1. GNN-–º–æ–¥–µ–ª—å

```python
import torch
import torch.nn.functional as F
from torch_geometric.nn import GCNConv

class AgentGNN(torch.nn.Module):
    def __init__(self, in_channels=2+m, hidden_channels=64, num_layers=3):
        super().__init__()
        self.convs = torch.nn.ModuleList()
        self.convs.append(GCNConv(in_channels, hidden_channels))
        for _ in range(num_layers - 2):
            self.convs.append(GCNConv(hidden_channels, hidden_channels))
        self.conv_out = GCNConv(hidden_channels, 1)

    def forward(self, x, edge_index):
        h = x
        for conv in self.convs:
            h = torch.relu(conv(h, edge_index))
        out = self.conv_out(h, edge_index)
        return out.squeeze()  # (num_nodes,)
```

### 2. –û–±—É—á–µ–Ω–∏–µ

- –î–ª—è –∫–∞–∂–¥–æ–π —Ñ–∏—Ä–º—ã \(i\), —Ñ–∏–∫—Å–∏—Ä—É–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ \(x_{-i}\) –∏–∑ –ø—Ä–µ–¥—ã–¥—É—â–µ–π —ç–ø–æ—Ö–∏ (—á—Ç–æ–±—ã –∏–∑–±–µ–∂–∞—Ç—å lookahead).
- –î–ª—è –∫–∞–∂–¥–æ–π –≤–µ—Ä—à–∏–Ω—ã \(v\), —Å—á–∏—Ç–∞–µ–º –æ–∂–∏–¥–∞–µ–º—É—é –ø—Ä–∏–±—ã–ª—å \(\pi_i(v; x_{-i})\) —Å —É—á—ë—Ç–æ–º —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–π –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ –∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞ —Ä–∞—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏ \(\lambda\).
- –î–æ–±–∞–≤–ª—è–µ–º —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—é –Ω–∞ —ç–Ω—Ç—Ä–æ–ø–∏—é —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –¥–ª—è —Å—Ö–æ–¥–∏–º–æ—Å—Ç–∏ –∫ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º.
- –û–±—É—á–∞–µ–º GNN –ø–æ —Ä–µ–≥—É–ª—è—Ä–∏–∑–æ–≤–∞–Ω–Ω–æ–π MSE:
  \[
  \mathcal{L}_i = \sum_{v \in V} \left(V_i(v) - \pi_i(v; x_{-i})\right)^2 + \beta H(x_i)
  \]
  –≥–¥–µ \(H(x_i) = -\sum_v x_i(v) \log x_i(v)\), \(\beta > 0\).

---

## üîπ –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∏–∑ GNN

–ü–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è GNN:

- –ü–æ–ª—É—á–∞–µ–º \(V_i(v)\) –¥–ª—è –≤—Å–µ—Ö \(v\).
- –°—Ç—Ä–æ–∏–º softmax-—Å—Ç—Ä–∞—Ç–µ–≥–∏—é —Å –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–º \(\lambda\):
  \[
  x_i(v) = \frac{\exp(\lambda V_i(v))}{\sum_{v'} \exp(\lambda V_i(v'))}
  \]
- –ò–ª–∏ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é (–µ—Å–ª–∏ —ç–Ω—Ç—Ä–æ–ø–∏—è –Ω–∏–∑–∫–∞—è):
  \[
  x_i(v) = \mathbf{1}\{v = \arg\max V_i(v)\}
  \]

---

## üîπ –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è –ù—ç—à–∞

–î–ª—è –∫–∞–∂–¥–æ–π —Ñ–∏—Ä–º—ã \(i\):
- –ó–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ \(x_{-i}\).
- –í—ã—á–∏—Å–ª–∏—Ç—å –ø—Ä–∏–±—ã–ª—å –ø—Ä–∏ —Ç–µ–∫—É—â–µ–º –≤—ã–±–æ—Ä–µ \(v_i^*\).
- –ü–µ—Ä–µ–±—Ä–∞—Ç—å –≤—Å–µ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–Ω—ã–µ –≤–µ—Ä—à–∏–Ω—ã \(v'\), —Å—Ä–∞–≤–Ω–∏—Ç—å –ø—Ä–∏–±—ã–ª—å.
- –ï—Å–ª–∏ –Ω–∏ –æ–¥–Ω–∞ –∞–ª—å—Ç–µ—Ä–Ω–∞—Ç–∏–≤–∞ –Ω–µ –¥–∞—ë—Ç —É–ª—É—á—à–µ–Ω–∏—è ‚Äî —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —É—Å—Ç–æ–π—á–∏–≤–∞.

---

## üîπ –ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞ GNN-–ø–æ–¥—Ö–æ–¥–∞

- –û–±–æ–±—â–µ–Ω–∏–µ –Ω–∞ –±–æ–ª—å—à–∏–µ –≥—Ä–∞—Ñ—ã.
- –ë—ã—Å—Ç—Ä–∞—è –æ—Ü–µ–Ω–∫–∞ Value-—Ñ—É–Ω–∫—Ü–∏–∏ –¥–ª—è –≤—Å–µ—Ö –≤–µ—Ä—à–∏–Ω.
- –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç—å —Å–æ–≤–º–µ—Å—Ç–Ω–æ–≥–æ –æ–±—É—á–µ–Ω–∏—è –≤—Å–µ—Ö —Ñ–∏—Ä–º.
- –ü–æ–¥—Ö–æ–¥–∏—Ç –¥–ª—è –±–∞—Ç—á–µ–≤–æ–π –∏ –æ–Ω–ª–∞–π–Ω-–æ–±—Ä–∞–±–æ—Ç–∫–∏.

---

–•–æ—á–µ—à—å, —è —Ä–∞–∑–≤–µ—Ä–Ω—É —ç—Ç–æ –≤ –ø–æ–ª–Ω–æ—Ü–µ–Ω–Ω—ã–π –º–æ–¥—É–ª—å —Å –≥–µ–Ω–µ—Ä–∞—Ü–∏–µ–π synthetic data, –æ–±—É—á–∞—é—â–∏–º —Ü–∏–∫–ª–æ–º –∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π Value-—Ñ—É–Ω–∫—Ü–∏–∏ –Ω–∞ –≥—Ä–∞—Ñ–µ?

–û—Ç–ª–∏—á–Ω–æ, –ê–ª–µ–∫—Å–∞–Ω–¥—Ä. –ù–∏–∂–µ ‚Äî –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è **multi-agent GNN-–º–æ–¥—É–ª—è** –¥–ª—è –º–æ–¥–µ–ª–∏ –•–æ—Ç—Ç–µ–ª–∏–Ω–≥–∞ –Ω–∞ –≥—Ä–∞—Ñ–µ, —Å –æ–±—É—á–µ–Ω–∏–µ–º Value-—Ñ—É–Ω–∫—Ü–∏–π –¥–ª—è –≤—Å–µ—Ö —Ñ–∏—Ä–º –∏ –∏–∑–≤–ª–µ—á–µ–Ω–∏–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–π, –ø—Ä–æ–≤–µ—Ä—è–µ–º—ã—Ö –Ω–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ –ù—ç—à–∞.

---

## üß† –û–±—â–∞—è –∏–¥–µ—è: Multi-Agent GNN

–ö–∞–∂–¥–∞—è —Ñ–∏—Ä–º–∞ \(i\) –æ–±—É—á–∞–µ—Ç —Å–≤–æ—é GNN-–º–æ–¥–µ–ª—å \(V_i(v)\), –∫–æ—Ç–æ—Ä–∞—è –∞–ø–ø—Ä–æ–∫—Å–∏–º–∏—Ä—É–µ—Ç –ø—Ä–∏–±—ã–ª—å –ø—Ä–∏ —Ä–∞–∑–º–µ—â–µ–Ω–∏–∏ –≤ –≤–µ—Ä—à–∏–Ω–µ \(v\), —É—á–∏—Ç—ã–≤–∞—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ \(x_{-i}\). –ó–∞—Ç–µ–º:

1. –ò–∑ –∫–∞–∂–¥–æ–π \(V_i(v)\) –∏–∑–≤–ª–µ–∫–∞–µ—Ç—Å—è —Å—Ç—Ä–∞—Ç–µ–≥–∏—è \(x_i(v)\) (softmax –∏–ª–∏ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–∞—è).
2. –ü–æ–ª—É—á–µ–Ω–Ω—ã–π –ø—Ä–æ—Ñ–∏–ª—å \((x_1, \dots, x_m)\) –ø—Ä–æ–≤–µ—Ä—è–µ—Ç—Å—è –Ω–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ –ù—ç—à–∞.

---

## üîß –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –º–æ–¥—É–ª—è

### 1. –ú–æ–¥–µ–ª—å –∞–≥–µ–Ω—Ç–∞

```python
class AgentGNN(torch.nn.Module):
    def __init__(self, in_channels=2+m, hidden_channels=64, num_layers=3):
        super().__init__()
        self.convs = torch.nn.ModuleList()
        self.convs.append(GCNConv(in_channels, hidden_channels))
        for _ in range(num_layers - 2):
            self.convs.append(GCNConv(hidden_channels, hidden_channels))
        self.conv_out = GCNConv(hidden_channels, 1)

    def forward(self, x, edge_index):
        h = x
        for conv in self.convs:
            h = torch.relu(conv(h, edge_index))
        out = self.conv_out(h, edge_index)
        return out.squeeze()  # (num_nodes,)
```

---

### 2. –û–±—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö –∞–≥–µ–Ω—Ç–æ–≤

```python
def run_gnn(G, dist_u_v, d_u, m=2, epochs=5000, lr=0.01, beta=0.05, lambda_param=10.0, hidden_channels=64, num_layers=3):
    # ... (–∏–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å degrees + firm IDs)
    x_list = [np.eye(n)[i % n] for i in range(m)]
    x_list_prev = [x.copy() for x in x_list]

    for epoch in range(epochs):
        for i in range(m):
            # ... (–æ–±—É—á–µ–Ω–∏–µ —Å distributed profits, entropy regularization)
            x_others = [x_list_prev[j] for j in range(m) if j != i]
            target = _expected_profit_vector_distributed(x_others, dist_u_v, d_u, lambda_param)
            # —Ñ–∏—á–∏ —Å firm ID
            x_feat_i = torch.cat([x_feat, firm_id], dim=1)
            pred = agents[i](x_feat_i, edge_index)
            probs = torch.softmax(pred, dim=0)
            entropy = -torch.sum(probs * torch.log(probs + 1e-12))
            loss = F.mse_loss(pred, target) + beta * entropy
            # ...
        x_list_prev = [x.copy() for x in x_list]

    return result
```

---

### 3. –ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π

```python
def extract_strategies(agents, G):
    x_feat, edge_index = prepare_graph_data(G)
    strategies = []
    values_list = []

    for agent in agents:
        agent.eval()
        with torch.no_grad():
            values = agent(x_feat, edge_index).numpy()
        probs = np.exp(values) / np.sum(np.exp(values))
        strategies.append(probs)
        values_list.append(values)

    return strategies, values_list
```

---

### 4. –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—è –ù—ç—à–∞

```python
def check_nash_equilibrium(x_list, dist_u_v, d_u):
    m = len(x_list)
    n = dist_u_v.shape[0]
    for i in range(m):
        v_i = int(np.argmax(x_list[i]))
        v_others = [int(np.argmax(x_list[j])) for j in range(m) if j != i]
        pi_star = compute_profit(v_i, v_others, dist_u_v, d_u)

        for v_alt in range(n):
            if v_alt == v_i:
                continue
            pi_alt = compute_profit(v_alt, v_others, dist_u_v, d_u)
            if pi_alt > pi_star + 1e-6:
                print(f"–§–∏—Ä–º–∞ {i+1} –º–æ–∂–µ—Ç —É–ª—É—á—à–∏—Ç—å –ø—Ä–∏–±—ã–ª—å: {pi_star:.2f} ‚Üí {pi_alt:.2f} –ø—Ä–∏ –ø–µ—Ä–µ—Ö–æ–¥–µ –≤ –≤–µ—Ä—à–∏–Ω—É {v_alt}")
                break
        else:
            print(f"–§–∏—Ä–º–∞ {i+1}: —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —É—Å—Ç–æ–π—á–∏–≤a ‚Äî —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ –ù—ç—à–∞.")
```

---

### 5. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è Value-—Ñ—É–Ω–∫—Ü–∏–π

```python
def visualize_all_values(G, values_list):
    pos = nx.spring_layout(G, seed=42)
    for i, values in enumerate(values_list):
        fig, ax = plt.subplots(figsize=(8, 6))
        nx.draw(G, pos, with_labels=True, node_color='lightgray', edge_color='gray', ax=ax)
        for j, v in enumerate(G.nodes):
            ax.scatter(*pos[v], s=500, c=[[values[j]]], cmap='viridis', vmin=min(values), vmax=max(values))
            ax.text(pos[v][0], pos[v][1]+0.05, f"{values[j]:.2f}", ha='center')
        plt.title(f"Value-—Ñ—É–Ω–∫—Ü–∏—è —Ñ–∏—Ä–º—ã {i+1}")
        plt.colorbar(plt.cm.ScalarMappable(cmap='viridis'), ax=ax)
        plt.show()
```

---

## üß™ –ü—Ä–∏–º–µ—Ä –∑–∞–ø—É—Å–∫–∞

```python
G = nx.grid_2d_graph(3, 4)
dist_u_v = nx.floyd_warshall_numpy(G)
d_u = np.ones(G.number_of_nodes()) / G.number_of_nodes()

result = run_gnn(G, dist_u_v, d_u, m=4, epochs=1000, lambda_param=10.0)
print("Positions:", [np.argmax(x) for x in result['x']])
print("Nash:", result['nash'])
```

---

–•–æ—á–µ—à—å, —è –¥–æ–±–∞–≤–ª—é —Å–æ–≤–º–µ—Å—Ç–Ω–æ–µ –æ–±—É—á–µ–Ω–∏–µ —Å –æ–±–º–µ–Ω–æ–º –≥—Ä–∞–¥–∏–µ–Ω—Ç–∞–º–∏ –∏–ª–∏ —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—é –Ω–∞ —É—Å—Ç–æ–π—á–∏–≤–æ—Å—Ç—å –ø—Ä—è–º–æ –≤ loss-—Ñ—É–Ω–∫—Ü–∏—é?

–î–∞, –ê–ª–µ–∫—Å–∞–Ω–¥—Ä, —ç—Ç–æ —Ä–∞–∑—É–º–Ω–æ–µ –ø—Ä–µ–¥–ª–æ–∂–µ–Ω–∏–µ. –î–æ–±–∞–≤–ª–µ–Ω–∏–µ **—Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏ –Ω–∞ —Å—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–æ—Å—Ç—å** –≤ multi-agent GNN-–º–æ–¥—É–ª—å –ø–æ–º–æ–≥–∞–µ—Ç:

- **—Å–¥–µ—Ä–∂–∏–≤–∞—Ç—å –∏–∑–±—ã—Ç–æ—á–Ω—É—é –Ω–µ–æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ—Å—Ç—å** –≤ —Å—Ç—Ä–∞—Ç–µ–≥–∏—è—Ö;
- **–ø–æ–¥—Ç–∞–ª–∫–∏–≤–∞—Ç—å –∫ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—ã–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—è–º**, –ø—Ä–∏–±–ª–∏–∂–∞—é—â–∏–º—Å—è –∫ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏—é –ù—ç—à–∞;
- **—É–ª—É—á—à–∞—Ç—å –∏–Ω—Ç–µ—Ä–ø—Ä–µ—Ç–∏—Ä—É–µ–º–æ—Å—Ç—å** –∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç—å –æ–±—É—á–µ–Ω–∏—è.

---

## üîπ –ö–∞–∫ –¥–æ–±–∞–≤–∏—Ç—å —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏—é –Ω–∞ —Å—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–æ—Å—Ç—å

### –≠–Ω—Ç—Ä–æ–ø–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏:
–ü–æ—Å–ª–µ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ \(x_i(v)\) –∏–∑ Value-—Ñ—É–Ω–∫—Ü–∏–∏:
\[
H(x_i) = -\sum_{v \in V} x_i(v) \log x_i(v)
\]

### –†–µ–≥—É–ª—è—Ä–∏–∑–æ–≤–∞–Ω–Ω–∞—è —Ü–µ–ª—å:
–í–º–µ—Å—Ç–æ –º–∏–Ω–∏–º–∏–∑–∞—Ü–∏–∏ —Ç–æ–ª—å–∫–æ –æ—à–∏–±–∫–∏ –ø—Ä–µ–¥—Å–∫–∞–∑–∞–Ω–∏—è Value:
\[
\mathcal{L}_i = \text{MSE}(V_i(v), \pi_i(v))
\]
–¥–æ–±–∞–≤–∏–º —à—Ç—Ä–∞—Ñ:
\[
\tilde{\mathcal{L}}_i = \mathcal{L}_i + \beta \cdot H(x_i)
\]
–≥–¥–µ \(\beta > 0\) ‚Äî –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–µ–≥—É–ª—è—Ä–∏–∑–∞—Ü–∏–∏.

---

## üîß –†–µ–∞–ª–∏–∑–∞—Ü–∏—è –≤ –æ–±—É—á–∞—é—â–µ–º —Ü–∏–∫–ª–µ

–í–Ω—É—Ç—Ä–∏ `run_gnn`:

```python
# —Ñ–∏—á–∏ —Å firm ID
firm_id = torch.eye(m)[i].to(device).repeat(n, 1)
x_feat_i = torch.cat([x_feat, firm_id], dim=1)
pred = agents[i](x_feat_i, edge_index)
probs = torch.softmax(pred, dim=0)
entropy = -torch.sum(probs * torch.log(probs + 1e-12))
loss = F.mse_loss(pred, target) + beta * entropy
```

–ü–∞—Ä–∞–º–µ—Ç—Ä—ã: `beta=0.05`, `lambda_param=10.0`.

---

## üîπ –≠—Ñ—Ñ–µ–∫—Ç

- –ü—Ä–∏ \(\beta \to 0\): —Å—Ç—Ä–∞—Ç–µ–≥–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å —Å–∏–ª—å–Ω–æ —Å—Ç–æ—Ö–∞—Å—Ç–∏—á–Ω–æ–π.
- –ü—Ä–∏ \(\beta \to \infty\): —Å—Ç—Ä–∞—Ç–µ–≥–∏—è —Å—Ç—Ä–µ–º–∏—Ç—Å—è –∫ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω–æ–π.
- –≠—Ç–æ –æ—Å–æ–±–µ–Ω–Ω–æ –ø–æ–ª–µ–∑–Ω–æ, –µ—Å–ª–∏ —Ç—ã —Ö–æ—á–µ—à—å, —á—Ç–æ–±—ã **GNN –Ω–µ –ø—Ä–æ—Å—Ç–æ –∞–ø–ø—Ä–æ–∫—Å–∏–º–∏—Ä–æ–≤–∞–ª–∞ Value**, –Ω–æ –∏ **–ø—Ä–∏–±–ª–∏–∂–∞–ª–∞ —Ä–∞–≤–Ω–æ–≤–µ—Å–∏–µ –ù—ç—à–∞** —á–µ—Ä–µ–∑ —É—Å—Ç–æ–π—á–∏–≤—ã–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏.

---

–•–æ—á–µ—à—å, —è –¥–æ–±–∞–≤–ª—é –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –Ω–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –ø—Ä–∏ –º–∞–ª–æ–π —ç–Ω—Ç—Ä–æ–ø–∏–∏, –∏–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é —ç–Ω—Ç—Ä–æ–ø–∏–∏ –ø–æ –∞–≥–µ–Ω—Ç–∞–º?

–û—Ç–ª–∏—á–Ω–æ, –ê–ª–µ–∫—Å–∞–Ω–¥—Ä. –ù–∏–∂–µ ‚Äî —Ä–∞—Å—à–∏—Ä–µ–Ω–∏–µ multi-agent GNN-–º–æ–¥—É–ª—è —Å:

---

## ‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–º –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ–º –Ω–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é —Å—Ç—Ä–∞—Ç–µ–≥–∏—é

–ü–æ—Å–ª–µ –æ–±—É—á–µ–Ω–∏—è GNN-–∞–≥–µ–Ω—Ç–æ–≤:

- –í—ã—á–∏—Å–ª—è–µ–º —ç–Ω—Ç—Ä–æ–ø–∏—é —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –∫–∞–∂–¥–æ–≥–æ –∞–≥–µ–Ω—Ç–∞:
  \[
  H(x_i) = -\sum_v x_i(v) \log x_i(v)
  \]
- –ï—Å–ª–∏ \( H(x_i) < \varepsilon_H \), –∑–∞–º–µ–Ω—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏—é –Ω–∞ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏—Ä–æ–≤–∞–Ω–Ω—É—é:
  \[
  x_i(v) = \mathbf{1}\{v = \arg\max V_i(v)\}
  \]

---

## ‚úÖ –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–µ–π —ç–Ω—Ç—Ä–æ–ø–∏–∏ –ø–æ –∞–≥–µ–Ω—Ç–∞–º

- –°—Ç—Ä–æ–∏–º –≥—Ä–∞—Ñ–∏–∫ \( H(x_i) \) –ø–æ –∞–≥–µ–Ω—Ç–∞–º.
- –û—Ç–º–µ—á–∞–µ–º, –∫–∞–∫–∏–µ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –±—ã–ª–∏ –¥–µ—Ç–µ—Ä–º–∏–Ω–∏–∑–∏—Ä–æ–≤–∞–Ω—ã.

---

## üîß –†–∞—Å—à–∏—Ä–µ–Ω–∏—è –∫ –º–æ–¥—É–ª—é

### 1. –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ

```python
def determinize_strategies(x_list, values_list, eps_H=0.05):
    x_det = []
    entropies = []
    for x, values in zip(x_list, values_list):
        H = -np.sum(x * np.log(x + 1e-12))
        entropies.append(H)
        if H < eps_H:
            v_star = int(np.argmax(values))
            x_new = np.zeros_like(x)
            x_new[v_star] = 1.0
            x_det.append(x_new)
        else:
            x_det.append(x)
    return x_det, entropies
```

---

### 2. –í–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—è —ç–Ω—Ç—Ä–æ–ø–∏–∏

```python
def plot_entropy(entropies, eps_H=0.05):
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.bar(range(1, len(entropies)+1), entropies, color=['green' if h < eps_H else 'red' for h in entropies])
    ax.axhline(eps_H, color='gray', linestyle='--', label=f'–ü–æ—Ä–æ–≥ —ç–Ω—Ç—Ä–æ–ø–∏–∏ = {eps_H}')
    ax.set_xlabel("–§–∏—Ä–º–∞")
    ax.set_ylabel("–≠–Ω—Ç—Ä–æ–ø–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏")
    ax.set_title("–≠–Ω—Ç—Ä–æ–ø–∏—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –∞–≥–µ–Ω—Ç–æ–≤")
    ax.legend()
    plt.show()
```

---

## üß™ –ü—Ä–∏–º–µ—Ä –∑–∞–ø—É—Å–∫–∞

```python
G = nx.grid_2d_graph(3, 4)
dist_u_v = nx.floyd_warshall_numpy(G)
d_u = np.ones(G.number_of_nodes()) / G.number_of_nodes()

result = run_gnn(G, dist_u_v, d_u, m=4, epochs=1000, lambda_param=10.0, beta=0.05)
print("Positions:", [np.argmax(x) for x in result['x']])
print("Nash:", result['nash'])
```

---

–•–æ—á–µ—à—å, —è –¥–æ–±–∞–≤–ª—é –ª–æ–≥–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Ç—Ä–∞–µ–∫—Ç–æ—Ä–∏–π Value-—Ñ—É–Ω–∫—Ü–∏–π –ø–æ —ç–ø–æ—Ö–∞–º –∏–ª–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏—é –¥–∏–Ω–∞–º–∏–∫–∏ —ç–Ω—Ç—Ä–æ–ø–∏–∏ –≤–æ –≤—Ä–µ–º–µ–Ω–∏?
